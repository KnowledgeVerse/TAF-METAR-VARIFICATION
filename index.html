<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Aviation Meteorology - METAR/TAF Decoder & Verification</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --bg-gradient: linear-gradient(
          135deg,
          #1a1a2e 0%,
          #16213e 50%,
          #0f3460 100%
        );
        --text-color: #eaeaea;
        --panel-bg: rgba(255, 255, 255, 0.05);
        --panel-border: rgba(233, 69, 96, 0.3);
        --header-text: #fff;
        --sub-text: #a0a0a0;
        --input-bg: rgba(0, 0, 0, 0.3);
        --input-text: #fff;
        --card-bg: rgba(0, 0, 0, 0.3);
        --footer-border: rgba(255, 255, 255, 0.1);
        --footer-text: #666;
        --accent-color: #e94560;
      }

      body.light-mode {
        --bg-gradient: linear-gradient(135deg, #f0f4f8 0%, #d9e2ec 100%);
        --text-color: #102a43;
        --panel-bg: rgba(255, 255, 255, 0.7);
        --panel-border: rgba(233, 69, 96, 0.4);
        --header-text: #102a43;
        --sub-text: #486581;
        --input-bg: rgba(255, 255, 255, 0.9);
        --input-text: #102a43;
        --card-bg: rgba(255, 255, 255, 0.6);
        --footer-border: rgba(16, 42, 67, 0.1);
        --footer-text: #486581;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: var(--bg-gradient);
        min-height: 100vh;
        color: var(--text-color);
        padding: 20px;
        transition:
          background 0.5s ease,
          color 0.5s ease;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        padding: 30px 0;
        border-bottom: 3px solid var(--accent-color);
        margin-bottom: 30px;
        position: relative;
      }

      header h1 {
        font-size: 2.5rem;
        color: var(--header-text);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        margin-bottom: 10px;
      }

      header p {
        color: var(--sub-text);
        font-size: 1.1rem;
      }

      .example-section {
        background: rgba(233, 69, 96, 0.1);
        border: 2px dashed var(--accent-color);
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 25px;
      }

      .example-section h3 {
        color: var(--accent-color);
        margin-bottom: 15px;
        font-size: 1.1rem;
      }

      .example-box {
        background: var(--input-bg);
        border-radius: 8px;
        padding: 12px 15px;
        margin: 10px 0;
        font-family: "Courier New", monospace;
        font-size: 13px;
        color: #10b981;
        cursor: pointer;
        transition: all 0.3s ease;
        border: 1px solid transparent;
      }

      .example-box:hover {
        border-color: #10b981;
        background: rgba(74, 222, 128, 0.1);
      }

      .example-label {
        color: var(--sub-text);
        font-size: 0.85rem;
        margin-bottom: 5px;
      }

      .main-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 25px;
        margin-bottom: 30px;
      }

      @media (max-width: 900px) {
        .main-grid {
          grid-template-columns: 1fr;
        }
      }

      .panel {
        background: var(--panel-bg);
        border-radius: 15px;
        padding: 25px;
        border: 1px solid var(--panel-border);
        backdrop-filter: blur(10px);
      }

      /* TAF Section Specifics */
      .panel-taf {
        background: linear-gradient(
          145deg,
          rgba(233, 69, 96, 0.1) 0%,
          rgba(233, 69, 96, 0.02) 100%
        );
        border: 1px solid rgba(233, 69, 96, 0.3);
      }
      .panel-taf h2 {
        color: #ff6b81;
      }
      .panel-taf h2::before {
        background: #ff6b81;
      }

      /* METAR Section Specifics */
      .panel-metar {
        background: linear-gradient(
          145deg,
          rgba(59, 130, 246, 0.1) 0%,
          rgba(59, 130, 246, 0.02) 100%
        );
        border: 1px solid rgba(59, 130, 246, 0.3);
      }
      .panel-metar h2 {
        color: #60a5fa;
      }
      .panel-metar h2::before {
        background: #60a5fa;
      }

      /* Light Mode Overrides */
      body.light-mode .panel-taf {
        background: rgba(255, 235, 238, 0.8);
        border-color: rgba(233, 69, 96, 0.3);
      }
      body.light-mode .panel-metar {
        background: rgba(235, 245, 255, 0.8);
        border-color: rgba(59, 130, 246, 0.3);
      }

      .panel h2 {
        color: var(--accent-color);
        margin-bottom: 20px;
        font-size: 1.4rem;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .panel h2::before {
        content: "";
        width: 4px;
        height: 24px;
        background: var(--accent-color);
        border-radius: 2px;
      }

      textarea {
        width: 100%;
        min-height: 150px;
        padding: 15px;
        border: 2px solid var(--panel-border);
        border-radius: 10px;
        background: var(--input-bg);
        color: var(--input-text);
        font-family: "Courier New", monospace;
        font-size: 14px;
        resize: vertical;
        transition: all 0.3s ease;
      }

      textarea:focus {
        outline: none;
        border-color: var(--accent-color);
        box-shadow: 0 0 15px rgba(233, 69, 96, 0.3);
      }

      textarea::placeholder {
        color: var(--sub-text);
        opacity: 0.7;
      }

      .btn-group {
        display: flex;
        gap: 15px;
        margin-top: 20px;
        flex-wrap: wrap;
      }

      button {
        padding: 12px 25px;
        border: none;
        border-radius: 8px;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .btn-primary {
        background: linear-gradient(135deg, var(--accent-color), #c73e54);
        color: #fff;
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(233, 69, 96, 0.4);
      }

      .btn-secondary {
        background: linear-gradient(135deg, #0f3460, #1a4a7a);
        color: #fff;
      }

      .btn-secondary:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(15, 52, 96, 0.4);
      }

      .btn-success {
        background: linear-gradient(135deg, #22c55e, #16a34a);
        color: #fff;
      }

      .btn-success:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(34, 197, 94, 0.4);
      }

      .output-panel {
        background: var(--output-bg);
        border-radius: 10px;
        padding: 20px;
        margin-top: 20px;
        border-left: 4px solid var(--accent-color);
        display: none;
      }

      .panel-header-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .output-panel.active {
        display: block;
        animation: fadeIn 0.5s ease;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .output-panel h3 {
        color: var(--accent-color);
        margin-bottom: 0;
        font-size: 1.2rem;
      }

      .decoded-item {
        display: flex;
        justify-content: space-between;
        padding: 10px 0;
        border-bottom: 1px solid var(--footer-border);
      }

      .decoded-item:last-child {
        border-bottom: none;
      }

      .decoded-label {
        color: var(--sub-text);
        font-weight: 500;
      }

      .decoded-value {
        color: var(--text-color);
        font-weight: 600;
        text-align: right;
      }

      .station-known {
        color: #10b981;
      }

      .station-unknown {
        color: #f87171;
      }

      .verification-panel {
        margin-top: 30px;
      }

      .verification-result {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-top: 20px;
      }

      .verify-card {
        background: var(--card-bg);
        border-radius: 10px;
        padding: 20px;
        text-align: center;
        border: 2px solid transparent;
        transition: all 0.3s ease;
      }

      .verify-card.correct {
        border-color: #10b981;
        background: rgba(74, 222, 128, 0.1);
      }

      .verify-card.incorrect {
        border-color: #f87171;
        background: rgba(248, 113, 113, 0.1);
      }

      .verify-card.partial {
        border-color: #fbbf24;
        background: rgba(251, 191, 36, 0.1);
      }

      .verify-card h4 {
        font-size: 0.9rem;
        color: var(--sub-text);
        margin-bottom: 10px;
        text-transform: uppercase;
      }

      .verify-card .status {
        font-size: 1.5rem;
        font-weight: 700;
      }

      .verify-card.correct .status {
        color: #10b981;
      }

      .verify-card.incorrect .status {
        color: #f87171;
      }

      .verify-card.partial .status {
        color: #fbbf24;
      }

      .overall-status {
        text-align: center;
        padding: 25px;
        border-radius: 15px;
        margin-top: 20px;
        font-size: 1.3rem;
        font-weight: 700;
      }

      .overall-status.verified {
        background: rgba(74, 222, 128, 0.2);
        border: 2px solid #10b981;
        color: #10b981;
      }

      .overall-status.partial {
        background: rgba(251, 191, 36, 0.2);
        border: 2px solid #fbbf24;
        color: #fbbf24;
      }

      .overall-status.not-verified {
        background: rgba(248, 113, 113, 0.2);
        border: 2px solid #f87171;
        color: #f87171;
      }

      .chart-container {
        background: var(--panel-bg);
        border-radius: 15px;
        padding: 25px;
        margin-top: 30px;
        border: 1px solid var(--panel-border);
      }

      .chart-container h2 {
        color: var(--accent-color);
        margin-bottom: 20px;
      }

      .chart-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 25px;
      }

      @media (max-width: 900px) {
        .chart-grid {
          grid-template-columns: 1fr;
        }
      }

      .chart-wrapper {
        background: var(--card-bg);
        border-radius: 10px;
        padding: 20px;
        position: relative;
        height: 300px;
      }

      .chart-wrapper h4 {
        color: var(--sub-text);
        margin-bottom: 15px;
        font-size: 0.95rem;
        text-align: center;
      }

      .legend {
        display: flex;
        justify-content: center;
        gap: 30px;
        margin-top: 20px;
        flex-wrap: wrap;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.9rem;
      }

      .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
      }

      .legend-color.match {
        background: #10b981;
      }

      .legend-color.mismatch {
        background: #f87171;
      }

      .info-section {
        background: var(--panel-bg);
        border-radius: 15px;
        padding: 25px;
        margin-top: 30px;
        border: 1px solid var(--panel-border);
      }

      .info-section h2 {
        color: var(--accent-color);
        margin-bottom: 20px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .info-grid {
        display: none; /* Hidden by default */
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
      }

      .info-grid.show {
        display: grid;
        animation: fadeIn 0.3s ease;
      }

      .info-card {
        background: var(--card-bg);
        border-radius: 10px;
        padding: 20px;
      }

      .info-card h4 {
        color: var(--text-color);
        margin-bottom: 15px;
        font-size: 1rem;
      }

      .info-card ul {
        list-style: none;
        padding: 0;
      }

      .info-card li {
        padding: 8px 0;
        border-bottom: 1px solid var(--footer-border);
        color: var(--sub-text);
        font-size: 0.9rem;
      }

      .info-card li:last-child {
        border-bottom: none;
      }

      .info-card li strong {
        color: var(--accent-color);
      }

      .taf-block {
        background: var(--card-bg);
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
        border-left: 3px solid var(--accent-color);
      }

      .metar-block {
        background: var(--card-bg);
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
        border-left: 4px solid var(--accent-color);
      }

      /* Dynamic Border Colors */
      .border-c1 {
        border-left-color: #e94560 !important;
      }
      .border-c2 {
        border-left-color: #3b82f6 !important;
      }
      .border-c3 {
        border-left-color: #10b981 !important;
      }
      .border-c4 {
        border-left-color: #f59e0b !important;
      }
      .border-c5 {
        border-left-color: #8b5cf6 !important;
      }
      .border-c6 {
        border-left-color: #06b6d4 !important;
      }

      /* Expanded Chart Styles */
      .chart-grid.expanded {
        grid-template-columns: 1fr;
      }

      .chart-grid.expanded .chart-wrapper {
        height: 500px;
        transition: height 0.3s ease;
      }

      .report-wrapper {
        background: var(--card-bg);
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 25px;
        border-left: 5px solid var(--accent-color);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
      }
      .report-wrapper:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
      }
      .report-header {
        background: rgba(0, 0, 0, 0.2);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 15px;
        border-bottom: 1px solid var(--footer-border);
      }
      .report-header h3 {
        margin: 0 0 5px 0;
        color: var(--accent-color);
        font-size: 1.2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .report-meta {
        display: flex;
        gap: 15px;
        font-size: 0.9rem;
        color: var(--sub-text);
        flex-wrap: wrap;
      }
      .report-meta span {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .taf-block-title {
        color: var(--accent-color);
        font-weight: 600;
        margin-bottom: 10px;
      }

      .change-indicator {
        display: inline-block;
        padding: 3px 10px;
        border-radius: 4px;
        font-size: 0.8rem;
        font-weight: 600;
        margin-right: 10px;
      }

      .change-fm {
        background: #3b82f6;
        color: #fff;
      }

      .change-becmg {
        background: #f59e0b;
        color: #fff;
      }

      .change-tempo {
        background: #8b5cf6;
        color: #fff;
      }

      .change-prob {
        background: #ec4899;
        color: #fff;
      }

      footer {
        text-align: center;
        padding-top: 2rem;
        margin-top: 4rem;
        border-top: 1px solid var(--footer-border);
        color: var(--footer-text);
      }

      .footer-title {
        font-size: 1.25rem;
        font-weight: 700;
        color: var(--header-text);
        margin-bottom: 0.5rem;
      }

      .footer-subtitle {
        color: var(--sub-text);
        font-size: 0.875rem;
        margin-bottom: 0.5rem;
      }

      .footer-author {
        font-size: 1.5rem;
        font-weight: 800;
        color: #ff9966;
        margin: 1rem 0;
        display: block;
      }

      .footer-btn {
        background: var(--card-bg);
        color: var(--sub-text);
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        font-size: 0.875rem;
        transition: all 0.3s;
        margin-top: 1rem;
        margin-bottom: 2rem;
        border: 1px solid var(--footer-border);
      }

      .footer-btn:hover {
        background: var(--panel-bg);
        color: var(--text-color);
      }

      .alert {
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        display: none;
      }

      .alert.show {
        display: block;
        animation: fadeIn 0.3s ease;
      }

      .alert-warning {
        background: rgba(251, 191, 36, 0.2);
        border: 1px solid #fbbf24;
        color: #fbbf24;
      }

      .alert-error {
        background: rgba(248, 113, 113, 0.2);
        border: 1px solid #f87171;
        color: #f87171;
      }

      .alert-success {
        background: rgba(74, 222, 128, 0.2);
        border: 1px solid #10b981;
        color: #10b981;
      }

      .quick-actions {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-wrap: wrap;
      }

      .quick-btn {
        padding: 8px 16px;
        font-size: 0.8rem;
        background: rgba(233, 69, 96, 0.2);
        border: 1px solid var(--accent-color);
        color: var(--accent-color);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .quick-btn:hover {
        background: var(--accent-color);
        color: #fff;
      }

      .theme-toggle-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        color: var(--text-color);
        padding: 10px 15px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.2rem;
        transition: all 0.3s ease;
        z-index: 100;
      }

      .theme-toggle-btn:hover {
        transform: scale(1.1);
        background: var(--accent-color);
        color: white;
      }

      /* Validity Badges */
      .badge-validity {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 700;
        margin-left: 10px;
        vertical-align: middle;
      }
      .badge-short {
        background: rgba(16, 185, 129, 0.2);
        color: #10b981;
        border: 1px solid #10b981;
      }
      .badge-long {
        background: rgba(59, 130, 246, 0.2);
        color: #3b82f6;
        border: 1px solid #3b82f6;
      }

      .diff-highlight {
        display: block;
        margin-top: 6px;
        color: #f87171;
        font-family: monospace;
        font-size: 0.85rem;
        background: rgba(248, 113, 113, 0.1);
        padding: 4px 8px;
        border-radius: 4px;
      }

      /* Logo & Dropdown Styles */
      .logo-container {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 100;
      }

      .logo-img {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid var(--accent-color);
        transition: transform 0.3s ease;
        object-fit: cover;
        background: #fff; /* Fallback background */
      }

      .logo-img:hover {
        transform: scale(1.1);
        box-shadow: 0 0 15px var(--accent-color);
      }

      .dropdown-menu {
        display: none;
        position: absolute;
        top: 60px;
        left: 0;
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        border-radius: 8px;
        min-width: 180px;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(15px);
        overflow: hidden;
        animation: fadeIn 0.3s ease;
      }

      .dropdown-menu.show {
        display: block;
      }

      .dropdown-menu a {
        color: var(--text-color);
        padding: 12px 20px;
        text-decoration: none;
        display: block;
        transition: all 0.2s;
        font-size: 0.95rem;
        border-bottom: 1px solid var(--footer-border);
      }

      .dropdown-menu a:last-child {
        border-bottom: none;
      }

      .dropdown-menu a:hover {
        background: var(--accent-color);
        color: #fff;
        padding-left: 25px;
      }

      /* Modal Styles */
      .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 2000;
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(5px);
      }

      .modal-overlay.active {
        display: flex;
        animation: fadeIn 0.3s ease;
      }

      .modal-content {
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        padding: 30px;
        border-radius: 15px;
        max-width: 500px;
        width: 90%;
        position: relative;
        color: var(--text-color);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      }

      .modal-close {
        position: absolute;
        top: 15px;
        right: 15px;
        font-size: 1.5rem;
        cursor: pointer;
        color: var(--sub-text);
        transition: color 0.3s;
      }

      .modal-close:hover {
        color: var(--accent-color);
      }

      .modal-header {
        margin-bottom: 20px;
        border-bottom: 1px solid var(--footer-border);
        padding-bottom: 10px;
      }

      .modal-header h2 {
        color: var(--accent-color);
        font-size: 1.5rem;
      }

      .form-group {
        margin-bottom: 15px;
      }

      .form-group label {
        display: block;
        margin-bottom: 5px;
        color: var(--sub-text);
      }

      .form-group input,
      .form-group textarea {
        width: 100%;
        padding: 10px;
        border-radius: 5px;
        border: 1px solid var(--panel-border);
        background: var(--input-bg);
        color: var(--input-text);
      }

      .form-group textarea {
        resize: vertical;
        min-height: 100px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <div class="logo-container">
          <img
            src="logo/logo.png"
            alt="Logo"
            class="logo-img"
            onclick="toggleDropdown(event)"
          />
          <div id="navDropdown" class="dropdown-menu">
            <a
              href="#"
              onclick="
                openModal('signinModal');
                return false;
              "
              >Sign In</a
            >
            <a
              href="#"
              onclick="
                openModal('aboutModal');
                return false;
              "
              >About</a
            >
            <a
              href="#"
              onclick="
                openModal('contactModal');
                return false;
              "
              >Contact Us</a
            >
          </div>
        </div>
        <button
          id="themeToggle"
          class="theme-toggle-btn"
          onclick="toggleTheme()"
          title="Toggle Light/Dark Mode"
        >
          <i class="fas fa-sun"></i>
        </button>
        <h1>‚úàÔ∏è Aviation Meteorology Decoder</h1>
        <p>
          METAR/TAF Decoder & Forecast Verification System | Based on IMD
          Standard Operational Procedure
        </p>
      </header>

      <!-- Example Section -->
      <div class="example-section">
        <h3>üìã File-Based Example Loading</h3>
        <div class="btn-group" style="margin-top: 0; gap: 10px">
          <button class="quick-btn" onclick="loadFileExample('default')">
            <i class="fas fa-file-alt"></i> Load Example (2 TAFs)
          </button>
          <button class="quick-btn" onclick="loadFileExample('long')">
            <i class="fas fa-file-invoice"></i> Load Long Example (Full)
          </button>
          <button class="quick-btn" onclick="loadFileExample('short')">
            <i class="fas fa-clock"></i> Load Short TAF Example
          </button>
        </div>
        <p style="font-size: 0.85rem; color: var(--sub-text); margin-top: 10px">
          Loads data from TAF.txt, Short_TAF.txt, and METAR.txt (ignoring
          headers)
        </p>
      </div>

      <div class="main-grid">
        <div class="panel panel-taf">
          <h2>TAF Input</h2>
          <div class="quick-actions">
            <button class="quick-btn" onclick="loadExample('taf')">
              Load TAF Ex
            </button>
            <button class="quick-btn" onclick="loadExample('cavok')">
              CAVOK Ex
            </button>
          </div>
          <textarea
            id="tafInput"
            placeholder="Enter TAF message here...
Example format: TAF VECC 110500Z 1106/1212 19008KT 3500 HZ SCT018 BKN100="
          ></textarea>
          <div class="btn-group">
            <button class="btn-primary" onclick="decodeTAF()">
              üîç Decode TAF
            </button>
            <button class="btn-secondary" onclick="clearTAF()">Clear</button>
          </div>
          <div id="tafAlert" class="alert"></div>
          <div id="tafOutput" class="output-panel">
            <div class="panel-header-actions">
              <h3>Decoded TAF</h3>
              <button class="quick-btn" onclick="downloadCSV('TAF')">
                <i class="fas fa-download"></i> CSV
              </button>
            </div>
            <div id="tafDecodedContent"></div>
          </div>
        </div>

        <div class="panel panel-metar">
          <h2>METAR Input</h2>
          <div class="quick-actions">
            <button class="quick-btn" onclick="loadExample('metar')">
              Load METAR Ex
            </button>
            <button class="quick-btn" onclick="loadExample('cavok')">
              CAVOK Ex
            </button>
          </div>
          <textarea
            id="metarInput"
            placeholder="Enter METAR message(s) here (one per line for multiple)...
Example format: METAR VECC 111200Z 20012KT 4000 HZ SCT020 BKN080 28/22 Q1008="
          ></textarea>
          <div class="btn-group">
            <button class="btn-primary" onclick="decodeMETAR()">
              üîç Decode METAR
            </button>
            <button class="btn-secondary" onclick="clearMETAR()">Clear</button>
          </div>
          <div id="metarAlert" class="alert"></div>
          <div id="metarOutput" class="output-panel">
            <div class="panel-header-actions">
              <h3>Decoded METAR</h3>
              <button class="quick-btn" onclick="downloadCSV('METAR')">
                <i class="fas fa-download"></i> CSV
              </button>
            </div>
            <div id="metarDecodedContent"></div>
          </div>
        </div>
      </div>

      <div class="panel verification-panel">
        <h2>Forecast Verification</h2>
        <p style="color: #a0a0a0; margin-bottom: 20px">
          Compare METAR observations against TAF forecast using IMD verification
          criteria
        </p>
        <div class="btn-group">
          <button class="btn-success" onclick="verifyForecast()">
            ‚úÖ Verify Forecast
          </button>
          <button
            class="btn-primary"
            id="downloadCSV"
            onclick="downloadCSV('ALL')"
          >
            <i class="fas fa-file-csv"></i> Download CSV Report
          </button>
          <button class="btn-secondary" onclick="clearAll()">Clear All</button>
        </div>
        <div id="verifyAlert" class="alert"></div>
        <div id="verificationOutput" class="output-panel">
          <h3>Verification Results</h3>
          <div class="verification-result" id="verificationCards"></div>
          <div id="overallStatus"></div>
        </div>
      </div>

      <div class="chart-container">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
          "
        >
          <h2 style="margin-bottom: 0">üìä Time-Based Graphical Analysis</h2>
          <button
            class="btn-secondary"
            onclick="toggleCharts()"
            id="chartToggleBtn"
            style="padding: 8px 15px; font-size: 0.85rem"
          >
            <i class="fas fa-expand"></i> Expand View
          </button>
        </div>
        <p style="color: #a0a0a0; margin-bottom: 20px">
          Visual timeline showing forecast accuracy across validity period
        </p>
        <div
          class="chart-controls"
          style="
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-bottom: 15px;
          "
        >
          <span
            style="
              align-self: center;
              color: var(--sub-text);
              font-size: 0.9rem;
              margin-right: auto;
            "
            ><i class="fas fa-info-circle"></i> Scroll/Drag to Pan, Pinch/Wheel
            to Zoom</span
          >
          <button class="quick-btn" onclick="zoomCharts(1.1)" title="Zoom In">
            <i class="fas fa-search-plus"></i>
          </button>
          <button class="quick-btn" onclick="zoomCharts(0.9)" title="Zoom Out">
            <i class="fas fa-search-minus"></i>
          </button>
          <button class="quick-btn" onclick="resetCharts()" title="Reset View">
            <i class="fas fa-undo"></i> Reset
          </button>
        </div>
        <div class="chart-grid">
          <div class="chart-wrapper">
            <h4>Wind Timeline</h4>
            <canvas id="windChart"></canvas>
          </div>
          <div class="chart-wrapper">
            <h4>Visibility Timeline</h4>
            <canvas id="visibilityChart"></canvas>
          </div>
          <div class="chart-wrapper">
            <h4>Weather Timeline</h4>
            <canvas id="weatherChart"></canvas>
          </div>
          <div class="chart-wrapper">
            <h4>Cloud Timeline</h4>
            <canvas id="cloudChart"></canvas>
          </div>
        </div>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color match"></div>
            <span>Match (Verified)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color mismatch"></div>
            <span>Mismatch (Not Verified)</span>
          </div>
        </div>
      </div>

      <div class="info-section">
        <h2 onclick="toggleInfoSection()">
          üìö Reference Information
          <i
            id="infoToggleIcon"
            class="fas fa-chevron-down"
            style="font-size: 1rem; transition: transform 0.3s"
          ></i>
        </h2>
        <div id="infoGrid" class="info-grid">
          <div class="info-card">
            <h4>METAR Structure</h4>
            <ul>
              <li><strong>Type:</strong> METAR or SPECI</li>
              <li><strong>Location:</strong> ICAO 4-letter code</li>
              <li><strong>Time:</strong> DDHHMMZ format</li>
              <li><strong>Wind:</strong> DDDFFKT or DDDFFGFFKT</li>
              <li><strong>Visibility:</strong> Meters (4 digits)</li>
              <li><strong>Weather:</strong> Present weather code</li>
              <li><strong>Cloud:</strong> NsNsNshshshs format</li>
              <li><strong>Temp:</strong> TT/TdTd (M for minus)</li>
              <li><strong>QNH:</strong> QPHPHPHPH (hPa)</li>
            </ul>
          </div>
          <div class="info-card">
            <h4>TAF Structure</h4>
            <ul>
              <li><strong>Type:</strong> TAF/TAF AMD/TAF COR</li>
              <li><strong>Location:</strong> ICAO 4-letter code</li>
              <li><strong>Issue:</strong> DDHHMMZ</li>
              <li><strong>Valid:</strong> DDHH/DDHH period</li>
              <li><strong>FM:</strong> From (permanent change)</li>
              <li><strong>BECMG:</strong> Becoming (gradual)</li>
              <li><strong>TEMPO:</strong> Temporary fluctuations</li>
              <li><strong>PROB:</strong> Probability (30/40)</li>
              <li><strong>NSW:</strong> No significant weather</li>
            </ul>
          </div>
          <div class="info-card">
            <h4>Verification Criteria (IMD)</h4>
            <ul>
              <li><strong>Wind Dir:</strong> ¬±20¬∞ (80%)</li>
              <li><strong>Wind Spd:</strong> ¬±5 kts (80%)</li>
              <li><strong>Vis &lt;800m:</strong> ¬±200m (80%)</li>
              <li><strong>Vis 800m-10km:</strong> ¬±30% (80%)</li>
              <li><strong>Precip:</strong> Occurrence (80%)</li>
              <li><strong>Cloud &lt;450m:</strong> ¬±1 category (70%)</li>
              <li><strong>Cloud Ht:</strong> ¬±30m/&pm;30% (70%)</li>
            </ul>
          </div>
          <div class="info-card">
            <h4>Weather Phenomena Codes</h4>
            <ul>
              <li><strong>RA:</strong> Rain</li>
              <li><strong>DZ:</strong> Drizzle</li>
              <li><strong>SN:</strong> Snow</li>
              <li><strong>TS:</strong> Thunderstorm</li>
              <li><strong>FG:</strong> Fog</li>
              <li><strong>HZ:</strong> Haze</li>
              <li><strong>+/-:</strong> Heavy/Light</li>
              <li><strong>VC:</strong> Vicinity</li>
            </ul>
          </div>
        </div>
      </div>

      <footer>
        <div style="margin-bottom: 1.5rem">
          <h3 class="footer-title">
            Bihar Aviation Weather Analysis & METAR/TAF Verification
          </h3>
          <p class="footer-subtitle">(ICAO Standard Based Interpretation)</p>
          <p class="footer-subtitle">Data Source: IMD Patna</p>
        </div>

        <div>
          <span class="footer-author">¬© Lal Kamal</span>
        </div>
        <p
          style="
            color: var(--sub-text);
            font-size: 0.875rem;
            margin-bottom: 1rem;
          "
        >
          2026 | All Rights Reserved
        </p>

        <p
          style="
            color: var(--sub-text);
            font-size: 0.875rem;
            margin-bottom: 1.5rem;
          "
        >
          <i class="fas fa-eye"></i> Visitors:
          <span
            id="visitorCount"
            style="font-family: monospace; font-weight: bold; color: #3b82f6"
            >...</span
          >
        </p>

        <button
          onclick="window.scrollTo({ top: 0, behavior: 'smooth' })"
          class="footer-btn"
        >
          Back to Top
          <i class="fas fa-arrow-up" style="margin-left: 0.25rem"></i>
        </button>
      </footer>
    </div>

    <!-- Modals -->
    <div id="signinModal" class="modal-overlay">
      <div class="modal-content">
        <span class="modal-close" onclick="closeModal('signinModal')"
          >&times;</span
        >
        <div class="modal-header">
          <h2>Sign In</h2>
        </div>
        <form
          onsubmit="
            event.preventDefault();
            closeModal('signinModal');
          "
        >
          <div class="form-group">
            <label>Email / Username</label>
            <input type="text" placeholder="Enter your email" required />
          </div>
          <div class="form-group">
            <label>Password</label>
            <input type="password" placeholder="Enter password" required />
          </div>
          <button type="submit" class="btn-primary" style="width: 100%">
            Sign In
          </button>
        </form>
      </div>
    </div>

    <div id="aboutModal" class="modal-overlay">
      <div class="modal-content">
        <span class="modal-close" onclick="closeModal('aboutModal')"
          >&times;</span
        >
        <div class="modal-header">
          <h2>About</h2>
        </div>
        <p style="margin-bottom: 15px; line-height: 1.6">
          <strong
            >Bihar Aviation Weather Analysis & METAR/TAF Verification
            System</strong
          >
        </p>
        <p style="margin-bottom: 15px; color: var(--sub-text)">
          This tool is designed to decode METAR and TAF reports and verify
          forecasts against observations based on ICAO and IMD standards.
        </p>
        <p style="color: var(--sub-text)">
          Developed by <strong>Lal Kamal</strong>.
        </p>
      </div>
    </div>

    <div id="contactModal" class="modal-overlay">
      <div class="modal-content">
        <span class="modal-close" onclick="closeModal('contactModal')"
          >&times;</span
        >
        <div class="modal-header">
          <h2>Contact Us</h2>
        </div>
        <div style="text-align: center">
          <p style="margin-bottom: 10px">
            <i
              class="fas fa-envelope"
              style="color: var(--accent-color); margin-right: 10px"
            ></i>
            support@aviationweather.com
          </p>
          <p style="margin-bottom: 20px">
            <i
              class="fas fa-phone"
              style="color: var(--accent-color); margin-right: 10px"
            ></i>
            +91 12345 67890
          </p>
          <div class="btn-group" style="justify-content: center">
            <button class="btn-secondary" onclick="closeModal('contactModal')">
              Close
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ========== INDIAN AVIATION STATION DATABASE ==========
      const stationDatabase = {
        VIDP: { name: "Delhi (IGI Airport)", fir: "Delhi FIR" },
        VABB: { name: "Mumbai (CSIA)", fir: "Mumbai FIR" },
        VECC: { name: "Kolkata (NSCBI Airport)", fir: "Kolkata FIR" },
        VOMM: { name: "Chennai (Chennai Airport)", fir: "Chennai FIR" },
        VOBL: { name: "Bangalore (Kempegowda Airport)", fir: "Chennai FIR" },
        VOHS: { name: "Hyderabad (Shamshabad)", fir: "Chennai FIR" },
        VOTV: { name: "Thiruvananthapuram", fir: "Chennai FIR" },
        VIDD: { name: "Delhi (Safdarjung)", fir: "Delhi FIR" },
        VIJP: { name: "Jaipur", fir: "Delhi FIR" },
        VILK: { name: "Lucknow", fir: "Delhi FIR" },
        VEAT: { name: "Agartala", fir: "Kolkata FIR" },
        VEBS: { name: "Bhubaneswar", fir: "Kolkata FIR" },
        VEPT: { name: "Patna", fir: "Kolkata FIR" },
        VEMN: { name: "Dibrugarh (Mohanbari)", fir: "Kolkata FIR" },
        VEGT: { name: "Guwahati", fir: "Kolkata FIR" },
        VANP: { name: "Nagpur", fir: "Mumbai FIR" },
        VABP: { name: "Bhopal", fir: "Mumbai FIR" },
        VAAH: { name: "Ahmedabad", fir: "Mumbai FIR" },
        VOAT: { name: "Agatti", fir: "Chennai FIR" },
        VOBG: { name: "Bangalore (HAL)", fir: "Chennai FIR" },
        VOBM: { name: "Belgaum", fir: "Chennai FIR" },
        VOCB: { name: "Coimbatore", fir: "Chennai FIR" },
        VOHB: { name: "Hubli", fir: "Chennai FIR" },
        VOHY: { name: "Hyderabad (Begumpet)", fir: "Chennai FIR" },
        VOCI: { name: "Kochi (CIAL)", fir: "Chennai FIR" },
        VOCL: { name: "Kozhikode (Calicut)", fir: "Chennai FIR" },
        VOMD: { name: "Madurai", fir: "Chennai FIR" },
        VOML: { name: "Mangalore", fir: "Chennai FIR" },
        VOMY: { name: "Mysore", fir: "Chennai FIR" },
        VOPC: { name: "Pondicherry", fir: "Chennai FIR" },
        VORY: { name: "Rajahmundry", fir: "Chennai FIR" },
        VOSM: { name: "Salem", fir: "Chennai FIR" },
        VOTP: { name: "Tirupati", fir: "Chennai FIR" },
        VOTR: { name: "Tiruchirappalli", fir: "Chennai FIR" },
        VOTK: { name: "Tuticorin", fir: "Chennai FIR" },
        VOBZ: { name: "Vijayawada", fir: "Chennai FIR" },
        VIAR: { name: "Amritsar", fir: "Delhi FIR" },
        VIBR: { name: "Bhuntar (Kulu)", fir: "Delhi FIR" },
        VIDN: { name: "Dehradun", fir: "Delhi FIR" },
        VIGG: { name: "Gaggal (Dharamsala)", fir: "Delhi FIR" },
        VIKO: { name: "Kota", fir: "Delhi FIR" },
        VILD: { name: "Ludhiana", fir: "Delhi FIR" },
        VIPT: { name: "Pantnagar", fir: "Delhi FIR" },
        VIUD: { name: "Udaipur", fir: "Delhi FIR" },
        VIBN: { name: "Varanasi", fir: "Delhi FIR" },
        VEAZ: { name: "Aizwal (Lengpui)", fir: "Kolkata FIR" },
        VECO: { name: "Cooch-Behar", fir: "Kolkata FIR" },
        VEMR: { name: "Dimapur", fir: "Kolkata FIR" },
        VEGY: { name: "Gaya", fir: "Kolkata FIR" },
        VEIM: { name: "Imphal", fir: "Kolkata FIR" },
        VEJS: { name: "Jamshedpur", fir: "Kolkata FIR" },
        VELR: { name: "North Lakhimpur (Lilabari)", fir: "Kolkata FIR" },
        VERC: { name: "Ranchi", fir: "Kolkata FIR" },
        VEBI: { name: "Shillong (Barapani)", fir: "Kolkata FIR" },
        VEDG: { name: "Durgapur", fir: "Kolkata FIR" },
        VAKE: { name: "Kandla", fir: "Mumbai FIR" },
        VOND: { name: "Nanded", fir: "Mumbai FIR" },
        VAUD: { name: "Udaipur", fir: "Mumbai FIR" },
        VISM: { name: "Shimla", fir: "Delhi FIR" },
        VERB: { name: "Fursatganj (Raebareli)", fir: "Delhi FIR" },
        VAAU: { name: "Aurangabad", fir: "Mumbai FIR" },
        VABV: { name: "Bhavnagar", fir: "Mumbai FIR" },
        VADU: { name: "Diu", fir: "Mumbai FIR" },
        VASU: { name: "Surat", fir: "Mumbai FIR" },
        VABO: { name: "Vadodara", fir: "Mumbai FIR" },
        VAJL: { name: "Jalgaon", fir: "Mumbai FIR" },
        VASD: { name: "Shirdi", fir: "Mumbai FIR" },
        VASL: { name: "Solapur", fir: "Mumbai FIR" },
        VAJJ: { name: "Juhu (Mumbai)", fir: "Mumbai FIR" },
        VAPR: { name: "Porbandar", fir: "Mumbai FIR" },
        VEKS: { name: "Kesod", fir: "Mumbai FIR" },
        VAGD: { name: "Gondia", fir: "Mumbai FIR" },
        VAID: { name: "Indore", fir: "Mumbai FIR" },
        VAKJ: { name: "Khajuraho", fir: "Mumbai FIR" },
        VAJB: { name: "Jabalpur", fir: "Mumbai FIR" },
        VARK: { name: "Rajkot", fir: "Mumbai FIR" },
        VOCP: { name: "Cuddapah", fir: "Chennai FIR" },
        VEPY: { name: "Pakyong", fir: "Kolkata FIR" },
        VEJH: { name: "Jharsuguda", fir: "Kolkata FIR" },
        VEJR: { name: "Jagdalpur", fir: "Kolkata FIR" },
        VIHR: { name: "Hisar", fir: "Delhi FIR" },
        VIKG: { name: "Kishangarh", fir: "Delhi FIR" },
        VOKN: { name: "Kannur", fir: "Chennai FIR" },
        VIRP: { name: "Rohini (Delhi)", fir: "Delhi FIR" },
        VERP: { name: "Raipur", fir: "Mumbai FIR" },
        VOPN: { name: "Puttaparthi", fir: "Chennai FIR" },
      };

      // Weather phenomenon decoder
      const weatherCodes = {
        RA: "Rain",
        DZ: "Drizzle",
        SN: "Snow",
        SG: "Snow Grains",
        IC: "Ice Crystals",
        PL: "Ice Pellets",
        GR: "Hail",
        GS: "Small Hail",
        BR: "Mist",
        FG: "Fog",
        FU: "Smoke",
        VA: "Volcanic Ash",
        DU: "Dust",
        SA: "Sand",
        HZ: "Haze",
        PO: "Dust/Sand Whirls",
        SQ: "Squalls",
        FC: "Funnel Cloud",
        SS: "Sandstorm",
        DS: "Duststorm",
        TS: "Thunderstorm",
        SH: "Showers",
        FZ: "Freezing",
        MI: "Shallow",
        BC: "Patches",
        PR: "Partial",
        DR: "Low Drifting",
        BL: "Blowing",
        VC: "Vicinity",
      };

      // Cloud amount decoder
      const cloudAmounts = {
        SKC: "Sky Clear (0/8)",
        FEW: "Few (1-2/8)",
        SCT: "Scattered (3-4/8)",
        BKN: "Broken (5-7/8)",
        OVC: "Overcast (8/8)",
        NSC: "No Significant Cloud",
      };

      // Global variables to store decoded data
      let decodedTAFs = [];
      let decodedMETARs = [];
      let charts = {};

      // ========== EXAMPLE DATA ==========
      const examples = {
        taf: "TAF VECC 110500Z 1106/1212 19008KT 3500 HZ SCT018 BKN100 TEMPO 1108/1112 2000 TSRA SCT015 FEW025CB OVC090=",
        metar: `METAR VECC 110800Z 20010KT 3000 HZ SCT015 BKN080 28/22 Q1008=
METAR VECC 111000Z 19012KT 2000 +TSRA SCT012 FEW025CB OVC080 26/21 Q1006=
METAR VECC 111200Z 20012KT 4000 HZ SCT020 BKN080 28/22 Q1008=`,
        cavok: {
          taf: "TAF VABB 120500Z 1206/1306 27008KT CAVOK=",
          metar: "METAR VABB 121200Z 27010KT CAVOK 30/24 Q1010=",
        },
      };

      // ========== FILE LOADING LOGIC ==========
      async function fetchFile(filename) {
        try {
          const response = await fetch(filename);
          if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);
          return await response.text();
        } catch (e) {
          console.error("Fetch error:", e);
          return null;
        }
      }

      function processFileContent(text, type) {
        if (!text) return [];
        const lines = text.split("\n");
        let startIndex = -1;

        // Find start line (YYYYMMDDHHMM TAF/METAR)
        const regex = type === "TAF" ? /^\d{12}\sTAF/ : /^\d{12}\sMETAR/;

        for (let i = 0; i < lines.length; i++) {
          if (regex.test(lines[i].trim())) {
            startIndex = i;
            break;
          }
        }

        if (startIndex === -1) return [];

        // Join all lines from start index and split by '='
        const content = lines.slice(startIndex).join("\n");
        return content
          .split("=")
          .map((s) => s.trim() + "=")
          .filter((s) => s.length > 10);
      }

      async function loadFileExample(mode) {
        const tafAlert = document.getElementById("tafAlert");
        showAlert(tafAlert, "Loading files...", "warning");

        let tafFile = "TAF.txt";
        if (mode === "short") tafFile = "Short_TAF.txt";

        const [tafText, metarText] = await Promise.all([
          fetchFile(tafFile),
          fetchFile("METAR.txt"),
        ]);

        if (!tafText || !metarText) {
          showAlert(
            tafAlert,
            "Error loading files. Ensure they exist in root.",
            "error",
          );
          return;
        }

        const rawTafs = processFileContent(tafText, "TAF");
        const rawMetars = processFileContent(metarText, "METAR");

        let selectedTafs = [];
        let selectedMetars = [];

        if (mode === "long") {
          selectedTafs = rawTafs;
          selectedMetars = rawMetars;
        } else {
          // Default or Short: Take first 2 TAFs
          selectedTafs = rawTafs.slice(0, 2);

          // Filter METARs corresponding to these TAFs
          // We need to parse TAFs temporarily to get validity
          const parsedTafs = selectedTafs
            .map((t) => parseTAF(t))
            .filter((t) => t);

          selectedMetars = rawMetars.filter((m) => {
            const parsedM = parseMETAR(m);
            if (!parsedM || !parsedM.time) return false;

            // Check if METAR time falls within any selected TAF validity
            return parsedTafs.some((t) => {
              if (t.station !== parsedM.station) return false;
              if (!t.validFrom || !t.validTo) return false;

              // Simple check: Just match the day for this example logic
              // A robust check would convert to full timestamps
              return (
                parsedM.time.day === t.validFrom.day ||
                parsedM.time.day === t.validTo.day
              );
            });
          });
        }

        document.getElementById("tafInput").value = selectedTafs.join("\n\n");
        document.getElementById("metarInput").value = selectedMetars.join("\n");

        showAlert(
          tafAlert,
          `Loaded ${selectedTafs.length} TAFs and ${selectedMetars.length} METARs`,
          "success",
        );
      }

      function getValidityDuration(from, to) {
        if (!from || !to) return 0;
        let start = parseInt(from.day) * 24 + parseInt(from.hour);
        let end = parseInt(to.day) * 24 + parseInt(to.hour);
        let diff = end - start;

        if (diff < 0) {
          // Handle month rollover (approximate logic for display)
          diff += 24 * 30; // Assume 30 day month for simple correction
          // Try to snap to standard durations
          if (Math.abs(diff - 30) < 5) return 30;
          if (Math.abs(diff - 9) < 5) return 9;
        }
        return diff;
      }

      // ========== UTILITY FUNCTIONS ==========
      function getStationInfo(code) {
        if (stationDatabase[code]) {
          return { ...stationDatabase[code], known: true };
        }
        return {
          name: "Unknown Station Code",
          fir: "Unknown FIR",
          known: false,
        };
      }

      function loadExample(type) {
        if (type === "taf") {
          document.getElementById("tafInput").value = examples.taf;
        } else if (type === "metar") {
          document.getElementById("metarInput").value = examples.metar;
        } else if (type === "cavok") {
          document.getElementById("tafInput").value = examples.cavok.taf;
          document.getElementById("metarInput").value = examples.cavok.metar;
        }
        showAlert(
          document.getElementById("tafAlert"),
          "Example loaded! Click Decode to view.",
          "success",
        );
      }

      function showAlert(element, message, type) {
        element.textContent = message;
        element.className = `alert alert-${type} show`;
        setTimeout(() => {
          element.className = "alert";
        }, 4000);
      }

      function clearTAF() {
        document.getElementById("tafInput").value = "";
        document.getElementById("tafOutput").classList.remove("active");
        document.getElementById("tafAlert").className = "alert";
        decodedTAFs = [];
      }

      function clearMETAR() {
        document.getElementById("metarInput").value = "";
        document.getElementById("metarOutput").classList.remove("active");
        document.getElementById("metarAlert").className = "alert";
        decodedMETARs = [];
      }

      function clearAll() {
        clearTAF();
        clearMETAR();
        document
          .getElementById("verificationOutput")
          .classList.remove("active");
        document.getElementById("verifyAlert").className = "alert";
        // Clear charts
        Object.values(charts).forEach((chart) => {
          if (chart) chart.destroy();
        });
        charts = {};
      }

      // ========== WIND DECODER ==========
      function decodeWind(windStr) {
        if (!windStr || windStr === "00000KT" || windStr === "CALM") {
          return {
            direction: "Calm",
            speed: 0,
            gust: null,
            variable: false,
            raw: windStr,
          };
        }

        // Variable wind
        if (windStr.startsWith("VRB")) {
          const speed = parseInt(windStr.substring(3, 5)) || 0;
          const gustMatch = windStr.match(/G(\d+)/);
          return {
            direction: "Variable",
            speed: speed,
            gust: gustMatch ? parseInt(gustMatch[1]) : null,
            variable: true,
            raw: windStr,
          };
        }

        // Standard wind
        const direction = parseInt(windStr.substring(0, 3));
        const speed = parseInt(windStr.substring(3, 5)) || 0;
        const gustMatch = windStr.match(/G(\d+)/);

        return {
          direction: isNaN(direction) ? null : direction,
          speed: speed,
          gust: gustMatch ? parseInt(gustMatch[1]) : null,
          variable: false,
          raw: windStr,
        };
      }

      function formatWind(wind) {
        if (!wind) return "Not reported";
        if (wind.direction === "Calm") return "Calm";
        if (wind.direction === "Variable") {
          let result = `Variable at ${wind.speed} KT`;
          if (wind.gust) result += `, Gusts to ${wind.gust} KT`;
          return result;
        }
        if (wind.direction === null) return wind.raw || "Unknown";
        let result = `${wind.direction}¬∞ at ${wind.speed} KT`;
        if (wind.gust) result += `, Gusts to ${wind.gust} KT`;
        return result;
      }

      // ========== WEATHER DECODER ==========
      function decodeWeather(wwStr) {
        if (!wwStr) return null;

        let result = [];
        let intensity = "";
        let descriptor = "";
        let phenomena = [];

        // Check for intensity
        if (wwStr.startsWith("+")) {
          intensity = "Heavy ";
          wwStr = wwStr.substring(1);
        } else if (wwStr.startsWith("-")) {
          intensity = "Light ";
          wwStr = wwStr.substring(1);
        }

        // Parse weather codes (2-letter codes)
        for (let i = 0; i < wwStr.length; i += 2) {
          const code = wwStr.substring(i, i + 2);
          if (weatherCodes[code]) {
            if (
              ["MI", "BC", "PR", "DR", "BL", "SH", "TS", "FZ"].includes(code)
            ) {
              descriptor += weatherCodes[code] + " ";
            } else {
              phenomena.push(weatherCodes[code]);
            }
          }
        }

        if (phenomena.length === 0 && descriptor) {
          return intensity + descriptor.trim();
        }
        if (phenomena.length === 0) return null;

        return intensity + descriptor + phenomena.join(" and ");
      }

      // ========== CLOUD DECODER ==========
      function decodeCloud(cloudStr) {
        if (!cloudStr) return null;

        if (cloudStr === "CAVOK") {
          return {
            type: "CAVOK",
            description:
              "Ceiling And Visibility OK (Vis ‚â•10km, No clouds below 5000ft)",
          };
        }
        if (cloudStr === "NSC") {
          return { type: "NSC", description: "No Significant Cloud" };
        }
        if (cloudStr === "SKC") {
          return { type: "SKC", description: "Sky Clear" };
        }
        if (cloudStr.startsWith("VV")) {
          const height = cloudStr.substring(2);
          if (height === "///") {
            return { type: "VV", description: "Vertical Visibility: Unknown" };
          }
          return {
            type: "VV",
            description: `Vertical Visibility: ${parseInt(height) * 100} ft`,
          };
        }

        // Regular cloud group: FEW015, SCT020CB, etc.
        const amount = cloudStr.substring(0, 3);
        const height = cloudStr.substring(3, 6);
        const cloudType = cloudStr.substring(6);

        let description = cloudAmounts[amount] || amount;
        if (height && height !== "///" && !isNaN(parseInt(height))) {
          description += ` at ${parseInt(height) * 100} ft`;
        }
        if (cloudType === "CB") {
          description += " (Cumulonimbus)";
        } else if (cloudType === "TCU") {
          description += " (Towering Cumulus)";
        }

        return {
          type: amount,
          height: height,
          cloudType: cloudType,
          description,
        };
      }

      // ========== METAR PARSER ==========
      function parseMETAR(metarStr) {
        metarStr = metarStr.trim().replace(/=$/, "");
        if (!metarStr) return null;

        const parts = metarStr.split(/\s+/);
        const result = {
          raw: metarStr,
          type: "METAR",
          station: null,
          stationInfo: null,
          time: null,
          wind: null,
          visibility: null,
          rvr: [],
          weather: [],
          clouds: [],
          temperature: null,
          dewpoint: null,
          qnh: null,
          supplementary: [],
        };

        let i = 0;

        // Check for Timestamp prefix (12 digits like 202412010500) and skip it
        if (parts[i] && /^\d{12}$/.test(parts[i])) {
          i++;
        }

        // Check for report type
        if (parts[i] === "METAR" || parts[i] === "SPECI") {
          result.type = parts[i];
          i++;
        }

        // Check for COR or NIL
        if (parts[i] === "COR") {
          result.correction = true;
          i++;
        }
        if (parts[i] === "NIL") {
          result.nil = true;
          return result;
        }
        if (parts[i] === "AUTO") {
          result.automated = true;
          i++;
        }

        // Station code (4 letters)
        if (
          i < parts.length &&
          parts[i].length === 4 &&
          /^[A-Z]{4}$/.test(parts[i])
        ) {
          result.station = parts[i];
          result.stationInfo = getStationInfo(parts[i]);
          i++;
        }

        // Time (DDHHMMZ)
        if (i < parts.length && /^\d{6}Z$/.test(parts[i])) {
          const day = parts[i].substring(0, 2);
          const hour = parts[i].substring(2, 4);
          const minute = parts[i].substring(4, 6);
          result.time = { raw: parts[i], day, hour, minute };
          i++;
        }

        // Wind
        if (
          i < parts.length &&
          (/^\d{5}KT$/.test(parts[i]) ||
            /^VRB\d+KT$/.test(parts[i]) ||
            /^\d{5}G\d+KT$/.test(parts[i]))
        ) {
          result.wind = decodeWind(parts[i]);
          i++;
        }

        // CAVOK check
        if (i < parts.length && parts[i] === "CAVOK") {
          result.cavok = true;
          result.visibility = {
            value: 10000,
            unit: "m",
            description: "10 km or more",
          };
          result.clouds.push({
            type: "CAVOK",
            description: "No clouds below 5000 ft",
          });
          i++;
        } else {
          // Visibility (4 digits)
          if (i < parts.length && /^\d{4}$/.test(parts[i])) {
            const vis = parseInt(parts[i]);
            result.visibility = {
              value: vis,
              unit: "m",
              description: vis >= 10000 ? "10 km or more" : `${vis} m`,
            };
            i++;
          }

          // RVR (Rxx/...)
          while (
            i < parts.length &&
            parts[i].startsWith("R") &&
            parts[i].includes("/")
          ) {
            result.rvr.push(parts[i]);
            i++;
          }

          // Weather codes
          while (i < parts.length && isWeatherCode(parts[i])) {
            const wx = decodeWeather(parts[i]);
            if (wx) result.weather.push(wx);
            i++;
          }

          // Clouds
          while (i < parts.length && isCloudCode(parts[i])) {
            result.clouds.push(decodeCloud(parts[i]));
            i++;
          }
        }

        // Temperature and Dewpoint (TT/TdTd or M05/M08)
        if (i < parts.length && /^M?\d{2}\/M?\d{2}$/.test(parts[i])) {
          const [temp, dew] = parts[i].split("/");
          result.temperature = temp.startsWith("M")
            ? -parseInt(temp.substring(1))
            : parseInt(temp);
          result.dewpoint = dew.startsWith("M")
            ? -parseInt(dew.substring(1))
            : parseInt(dew);
          i++;
        }

        // QNH (Qxxxx)
        if (i < parts.length && /^Q\d{4}$/.test(parts[i])) {
          result.qnh = parseInt(parts[i].substring(1));
          i++;
        }

        // Supplementary information
        if (i < parts.length) {
          result.supplementary = parts.slice(i);
        }

        return result;
      }

      function isWeatherCode(str) {
        // Weather codes like RA, DZ, SN, TS, FG, HZ, +RA, -DZ, TSRA, etc.
        if (str === "NSW") return true;
        const weatherPattern =
          /^[+-]?(MI|BC|PR|DR|BL|SH|TS|FZ|VC)?(DZ|RA|SN|SG|IC|PL|GR|GS|BR|FG|FU|VA|DU|SA|HZ|PO|SQ|FC|SS|DS)+$/;
        return weatherPattern.test(str);
      }

      function isCloudCode(str) {
        // Cloud codes: FEW, SCT, BKN, OVC followed by 3 digits
        // Or VVxxx, NSC, SKC, CAVOK
        return (
          /^(FEW|SCT|BKN|OVC)\d{3}(CB|TCU)?$/.test(str) ||
          /^VV\d{3}$/.test(str) ||
          str === "NSC" ||
          str === "SKC" ||
          str === "CAVOK"
        );
      }

      // ========== TAF PARSER ==========
      function parseTAF(tafStr) {
        tafStr = tafStr.trim().replace(/=$/, "");
        if (!tafStr) return null;

        const parts = tafStr.split(/\s+/);
        const result = {
          raw: tafStr,
          type: "TAF",
          amendment: false,
          correction: false,
          station: null,
          stationInfo: null,
          issueTime: null,
          validFrom: null,
          validTo: null,
          baseForecast: {
            wind: null,
            visibility: null,
            weather: [],
            clouds: [],
          },
          changes: [],
        };

        let i = 0;

        // Check for Timestamp prefix (12 digits like 202412010500) and skip it
        if (parts[i] && /^\d{12}$/.test(parts[i])) {
          i++;
        }

        // Check for TAF type
        if (parts[i] === "TAF") {
          i++;
        }
        if (parts[i] === "AMD") {
          result.amendment = true;
          i++;
        }
        if (parts[i] === "COR") {
          result.correction = true;
          i++;
        }

        // Station code
        if (
          i < parts.length &&
          parts[i].length === 4 &&
          /^[A-Z]{4}$/.test(parts[i])
        ) {
          result.station = parts[i];
          result.stationInfo = getStationInfo(parts[i]);
          i++;
        }

        // Issue time
        if (i < parts.length && /^\d{6}Z$/.test(parts[i])) {
          const day = parts[i].substring(0, 2);
          const hour = parts[i].substring(2, 4);
          const minute = parts[i].substring(4, 6);
          result.issueTime = { raw: parts[i], day, hour, minute };
          i++;
        }

        // Validity period
        if (i < parts.length && /^\d{4}\/\d{4}$/.test(parts[i])) {
          const [from, to] = parts[i].split("/");
          result.validFrom = {
            day: from.substring(0, 2),
            hour: from.substring(2, 4),
          };
          result.validTo = {
            day: to.substring(0, 2),
            hour: to.substring(2, 4),
          };
          i++;
        }

        // Parse base forecast and change groups
        let currentGroup = result.baseForecast;

        while (i < parts.length) {
          const part = parts[i];

          // FM (From) - permanent change
          if (
            part === "FM" &&
            i + 1 < parts.length &&
            /^\d{4}$/.test(parts[i + 1])
          ) {
            const time = parts[i + 1];
            currentGroup = {
              type: "FM",
              time: { day: time.substring(0, 2), hour: time.substring(2, 4) },
              wind: null,
              visibility: null,
              weather: [],
              clouds: [],
            };
            result.changes.push(currentGroup);
            i += 2;
            continue;
          }

          // BECMG - Becoming
          if (
            part === "BECMG" &&
            i + 1 < parts.length &&
            /^\d{4}\/\d{4}$/.test(parts[i + 1])
          ) {
            const [from, to] = parts[i + 1].split("/");
            currentGroup = {
              type: "BECMG",
              from: { day: from.substring(0, 2), hour: from.substring(2, 4) },
              to: { day: to.substring(0, 2), hour: to.substring(2, 4) },
              wind: null,
              visibility: null,
              weather: [],
              clouds: [],
            };
            result.changes.push(currentGroup);
            i += 2;
            continue;
          }

          // TEMPO - Temporary
          if (
            part === "TEMPO" &&
            i + 1 < parts.length &&
            /^\d{4}\/\d{4}$/.test(parts[i + 1])
          ) {
            const [from, to] = parts[i + 1].split("/");
            currentGroup = {
              type: "TEMPO",
              from: { day: from.substring(0, 2), hour: from.substring(2, 4) },
              to: { day: to.substring(0, 2), hour: to.substring(2, 4) },
              wind: null,
              visibility: null,
              weather: [],
              clouds: [],
            };
            result.changes.push(currentGroup);
            i += 2;
            continue;
          }

          // PROB30 or PROB40
          if (/^PROB\d{2}$/.test(part)) {
            currentGroup = {
              type: part,
              probability: parseInt(part.substring(4)),
              wind: null,
              visibility: null,
              weather: [],
              clouds: [],
            };
            result.changes.push(currentGroup);
            i++;
            continue;
          }

          // NOSIG
          if (part === "NOSIG") {
            result.nosig = true;
            i++;
            continue;
          }

          // Parse forecast elements
          if (
            /^\d{5}KT$/.test(part) ||
            /^VRB\d+KT$/.test(part) ||
            /^\d{5}G\d+KT$/.test(part)
          ) {
            currentGroup.wind = decodeWind(part);
            i++;
          } else if (/^\d{4}$/.test(part)) {
            currentGroup.visibility = { value: parseInt(part), unit: "m" };
            i++;
          } else if (isWeatherCode(part)) {
            if (part === "NSW") {
              currentGroup.weather.push("No Significant Weather");
            } else {
              const wx = decodeWeather(part);
              if (wx) currentGroup.weather.push(wx);
            }
            i++;
          } else if (isCloudCode(part)) {
            currentGroup.clouds.push(decodeCloud(part));
            i++;
          } else {
            i++;
          }
        }

        return result;
      }

      // ========== DECODE FUNCTIONS ==========
      function renderItem(label, value) {
        return `<div class="decoded-item"><span class="decoded-label">${label}</span><span class="decoded-value">${value}</span></div>`;
      }

      function decodeTAF() {
        let input = document.getElementById("tafInput").value.trim();
        // Flatten input: replace newlines and multiple spaces with single space
        input = input.replace(/\s+/g, " ");
        const rawTafs = input
          .split("=")
          .map((t) => t.trim())
          .filter((t) => t.length > 5);

        const alertDiv = document.getElementById("tafAlert");
        const outputDiv = document.getElementById("tafOutput");
        const contentDiv = document.getElementById("tafDecodedContent");

        const borderColors = [
          "border-c1",
          "border-c2",
          "border-c3",
          "border-c4",
          "border-c5",
          "border-c6",
        ];

        if (rawTafs.length === 0) {
          showAlert(alertDiv, "Please enter a TAF message", "warning");
          return;
        }

        decodedTAFs = [];
        let html = "";
        let successCount = 0;

        rawTafs.forEach((tafStr, idx) => {
          const decodedTAF = parseTAF(tafStr);
          if (decodedTAF && decodedTAF.station) {
            decodedTAFs.push(decodedTAF);
            successCount++;

            // Validity Badge Logic
            const duration = getValidityDuration(
              decodedTAF.validFrom,
              decodedTAF.validTo,
            );
            let badgeHtml = "";
            if (duration === 9) {
              badgeHtml =
                '<span class="badge-validity badge-short">üü¢ SHORT TAF (9 HR)</span>';
            } else if (duration === 30) {
              badgeHtml =
                '<span class="badge-validity badge-long">üîµ LONG TAF (30 HR)</span>';
            }

            const colorClass = borderColors[idx % borderColors.length];
            html += `<div class="report-wrapper ${colorClass}">`;

            // Header
            html += `<div class="report-header">`;
            html += `<h3>${decodedTAF.station} <span style="font-size:0.9rem; color:var(--text-color); opacity:0.8;">${decodedTAF.stationInfo.name}</span>${badgeHtml}</h3>`;
            html += `<div class="report-meta">`;

            let typeStr = decodedTAF.type;
            if (decodedTAF.amendment) typeStr += " (AMD)";
            if (decodedTAF.correction) typeStr += " (COR)";
            html += `<span><i class="fas fa-tag"></i> ${typeStr}</span>`;

            if (decodedTAF.issueTime) {
              html += `<span><i class="far fa-clock"></i> Issued: ${decodedTAF.issueTime.day}/${decodedTAF.issueTime.hour}:${decodedTAF.issueTime.minute}Z</span>`;
            }
            if (decodedTAF.validFrom && decodedTAF.validTo) {
              html += `<span><i class="far fa-calendar-alt"></i> Valid: ${decodedTAF.validFrom.day}/${decodedTAF.validFrom.hour}Z - ${decodedTAF.validTo.day}/${decodedTAF.validTo.hour}Z</span>`;
            }
            html += `</div></div>`;

            // Base Forecast
            html += `<div class="taf-block" style="border-left-color: inherit; opacity: 0.9;">`;
            html += `<div class="taf-block-title">Base Forecast</div>`;

            if (decodedTAF.baseForecast.wind)
              html += renderItem(
                "Wind",
                formatWind(decodedTAF.baseForecast.wind),
              );
            if (decodedTAF.baseForecast.visibility)
              html += renderItem(
                "Visibility",
                decodedTAF.baseForecast.visibility.value + " m",
              );
            if (decodedTAF.baseForecast.weather.length > 0)
              html += renderItem(
                "Weather",
                decodedTAF.baseForecast.weather.join(", "),
              );
            if (decodedTAF.baseForecast.clouds.length > 0) {
              const cloudDesc = decodedTAF.baseForecast.clouds
                .map((c) => c.description || c)
                .join("; ");
              html += renderItem("Clouds", cloudDesc);
            }
            html += `</div>`;

            // Change groups
            decodedTAF.changes.forEach((change) => {
              let changeTitle = "";
              let changeClass = "";
              switch (change.type) {
                case "FM":
                  changeTitle = `FROM Day ${change.time.day} ${change.time.hour}:00Z`;
                  changeClass = "change-fm";
                  break;
                case "BECMG":
                  changeTitle = `BECOMING ${change.from.day}/${change.from.hour}Z - ${change.to.day}/${change.to.hour}Z`;
                  changeClass = "change-becmg";
                  break;
                case "TEMPO":
                  changeTitle = `TEMPO ${change.from.day}/${change.from.hour}Z - ${change.to.day}/${change.to.hour}Z`;
                  changeClass = "change-tempo";
                  break;
                default:
                  if (change.type && change.type.startsWith("PROB")) {
                    changeTitle = `PROBABILITY ${change.probability}%`;
                    changeClass = "change-prob";
                  }
              }

              html += `<div class="taf-block" style="border-left: 3px solid rgba(255,255,255,0.2);">`;
              html += `<div class="taf-block-title"><span class="change-indicator ${changeClass}">${change.type}</span>${changeTitle}</div>`;

              if (change.wind)
                html += renderItem("Wind", formatWind(change.wind));
              if (change.visibility)
                html += renderItem(
                  "Visibility",
                  change.visibility.value + " m",
                );
              if (change.weather.length > 0)
                html += renderItem("Weather", change.weather.join(", "));
              if (change.clouds.length > 0) {
                const cloudDesc = change.clouds
                  .map((c) => c.description || c)
                  .join("; ");
                html += renderItem("Clouds", cloudDesc);
              }
              html += `</div>`;
            });

            if (decodedTAF.nosig) {
              html +=
                '<div class="taf-block"><div class="taf-block-title">No Significant Changes Expected</div></div>';
            }

            html += `</div>`; // Close wrapper
          }
        });

        if (successCount === 0) {
          showAlert(
            alertDiv,
            "Unable to parse TAF. Please check the format.",
            "error",
          );
          return;
        }

        alertDiv.className = "alert";
        outputDiv.classList.add("active");
        contentDiv.innerHTML = html;
        showAlert(
          alertDiv,
          `${successCount} TAF(s) decoded successfully!`,
          "success",
        );
      }

      function decodeMETAR() {
        const input = document.getElementById("metarInput").value.trim();
        const alertDiv = document.getElementById("metarAlert");
        const outputDiv = document.getElementById("metarOutput");
        const contentDiv = document.getElementById("metarDecodedContent");

        const borderColors = [
          "border-c1",
          "border-c2",
          "border-c3",
          "border-c4",
          "border-c5",
          "border-c6",
        ];

        if (!input) {
          showAlert(alertDiv, "Please enter a METAR message", "warning");
          return;
        }

        // Parse multiple METARs
        let metarLines;
        // If input contains '=', assume it is the delimiter and flatten newlines (handles broken lines)
        if (input.includes("=")) {
          metarLines = input
            .replace(/\s+/g, " ")
            .split("=")
            .map((line) => line.trim())
            .filter((line) => line.length > 0);
        } else {
          // Fallback to line-by-line if no '=' found
          metarLines = input
            .split("\n")
            .map((line) => line.trim())
            .filter((line) => line.length > 0);
        }

        if (metarLines.length === 0) {
          showAlert(alertDiv, "Please enter a valid METAR message", "warning");
          return;
        }

        decodedMETARs = [];
        let html = "";

        metarLines.forEach((line, idx) => {
          const metar = parseMETAR(line);
          if (metar) {
            decodedMETARs.push(metar);

            const colorClass = borderColors[idx % borderColors.length];
            html += `<div class="metar-block ${colorClass}">`;

            // Station info
            const stationClass = metar.stationInfo.known
              ? "station-known"
              : "station-unknown";
            html += `
                        <div class="decoded-item">
                            <span class="decoded-label">Station</span>
                            <span class="decoded-value ${stationClass}">${metar.station} - ${metar.stationInfo.name}</span>
                        </div>
                    `;

            // Report type
            let typeStr = metar.type;
            if (metar.correction) typeStr += " (Corrected)";
            if (metar.automated) typeStr += " (Automated)";
            html += `
                        <div class="decoded-item">
                            <span class="decoded-label">Report Type</span>
                            <span class="decoded-value">${typeStr}</span>
                        </div>
                    `;

            // Time
            if (metar.time) {
              html += `
                            <div class="decoded-item">
                                <span class="decoded-label">Observation Time</span>
                                <span class="decoded-value">Day ${metar.time.day}, ${metar.time.hour}:${metar.time.minute} UTC</span>
                            </div>
                        `;
            }

            // Wind
            if (metar.wind) {
              html += `
                            <div class="decoded-item">
                                <span class="decoded-label">Wind</span>
                                <span class="decoded-value">${formatWind(metar.wind)}</span>
                            </div>
                        `;
            }

            // Visibility
            if (metar.visibility) {
              html += `
                            <div class="decoded-item">
                                <span class="decoded-label">Visibility</span>
                                <span class="decoded-value">${metar.visibility.description}</span>
                            </div>
                        `;
            }

            // RVR
            if (metar.rvr.length > 0) {
              html += `
                            <div class="decoded-item">
                                <span class="decoded-label">RVR</span>
                                <span class="decoded-value">${metar.rvr.join(", ")}</span>
                            </div>
                        `;
            }

            // Weather
            if (metar.weather.length > 0) {
              html += `
                            <div class="decoded-item">
                                <span class="decoded-label">Present Weather</span>
                                <span class="decoded-value">${metar.weather.join(", ")}</span>
                            </div>
                        `;
            }

            // Clouds
            if (metar.clouds.length > 0) {
              const cloudDesc = metar.clouds
                .map((c) => c.description || c)
                .join("; ");
              html += `
                            <div class="decoded-item">
                                <span class="decoded-label">Clouds</span>
                                <span class="decoded-value">${cloudDesc}</span>
                            </div>
                        `;
            }

            // Temperature
            if (metar.temperature !== null) {
              html += `
                            <div class="decoded-item">
                                <span class="decoded-label">Temperature</span>
                                <span class="decoded-value">${metar.temperature}¬∞C</span>
                            </div>
                        `;
            }

            // Dewpoint
            if (metar.dewpoint !== null) {
              html += `
                            <div class="decoded-item">
                                <span class="decoded-label">Dewpoint</span>
                                <span class="decoded-value">${metar.dewpoint}¬∞C</span>
                            </div>
                        `;
            }

            // QNH
            if (metar.qnh) {
              html += `
                            <div class="decoded-item">
                                <span class="decoded-label">QNH</span>
                                <span class="decoded-value">${metar.qnh} hPa</span>
                            </div>
                        `;
            }

            // Supplementary
            if (metar.supplementary.length > 0) {
              html += `
                            <div class="decoded-item">
                                <span class="decoded-label">Supplementary</span>
                                <span class="decoded-value">${metar.supplementary.join(" ")}</span>
                            </div>
                        `;
            }

            html += `</div>`; // Close metar-block
          }
        });

        if (decodedMETARs.length === 0) {
          showAlert(
            alertDiv,
            "Unable to parse any METAR. Please check the format.",
            "error",
          );
          return;
        }

        alertDiv.className = "alert";
        outputDiv.classList.add("active");
        contentDiv.innerHTML = html;
        showAlert(
          alertDiv,
          `${decodedMETARs.length} METAR(s) decoded successfully!`,
          "success",
        );
      }

      // ========== VERIFICATION FUNCTIONS ==========
      function verifyWind(tafWind, metarWind) {
        if (!tafWind || !metarWind)
          return { verified: null, reason: "Missing data" };

        const fcstStr = formatWind(tafWind);
        const obsStr = formatWind(metarWind);
        const diffHtml = `<span class="diff-highlight">Fcst: ${fcstStr}<br>Obs: ${obsStr}</span>`;

        if (tafWind.direction === "Calm" && metarWind.direction === "Calm")
          return { verified: true, deviation: 0 };
        if (
          tafWind.direction === "Variable" ||
          metarWind.direction === "Variable"
        ) {
          const speedDiff = Math.abs(tafWind.speed - metarWind.speed);
          return {
            verified: speedDiff <= 5,
            deviation: speedDiff,
            type: "speed",
            reason:
              speedDiff > 5
                ? `Speed diff: ${speedDiff} kt (allowed: ¬±5 kt)${diffHtml}`
                : null,
          };
        }

        const dirDiff = Math.abs(tafWind.direction - metarWind.direction);
        const normalizedDiff = dirDiff > 180 ? 360 - dirDiff : dirDiff;
        const speedDiff = Math.abs(tafWind.speed - metarWind.speed);

        const dirVerified = normalizedDiff <= 20;
        const speedVerified = speedDiff <= 5;

        if (dirVerified && speedVerified) {
          return {
            verified: true,
            deviation: normalizedDiff,
            type: "direction",
          };
        } else if (!dirVerified) {
          return {
            verified: false,
            deviation: normalizedDiff,
            type: "direction",
            reason: `Direction diff: ${normalizedDiff}¬∞ (allowed: ¬±20¬∞)${diffHtml}`,
          };
        } else {
          return {
            verified: false,
            deviation: speedDiff,
            type: "speed",
            reason: `Speed diff: ${speedDiff} kt (allowed: ¬±5 kt)${diffHtml}`,
          };
        }
      }

      function verifyVisibility(tafVis, metarVis) {
        if (!tafVis || !metarVis)
          return { verified: null, reason: "Missing data" };

        const tafValue = tafVis.value;
        const metarValue = metarVis.value;

        const diffHtml = `<span class="diff-highlight">Fcst: ${tafValue}m<br>Obs: ${metarValue}m</span>`;

        let allowedDiff;
        if (tafValue <= 800) {
          allowedDiff = 200;
        } else if (tafValue <= 10000) {
          allowedDiff = tafValue * 0.3;
        } else {
          const verified = metarValue >= 10000;
          return {
            verified: verified,
            deviation: Math.abs(metarValue - tafValue),
            reason: verified
              ? null
              : `Forecast ‚â•10km but Observed <10km${diffHtml}`,
          };
        }

        const diff = Math.abs(metarValue - tafValue);
        return {
          verified: diff <= allowedDiff,
          deviation: diff,
          reason:
            diff > allowedDiff
              ? `Diff: ${diff}m (allowed: ${Math.round(allowedDiff)}m)${diffHtml}`
              : null,
        };
      }

      function verifyWeather(tafWx, metarWx) {
        const tafHasWx =
          tafWx &&
          tafWx.length > 0 &&
          !tafWx.includes("No Significant Weather");
        const metarHasWx = metarWx && metarWx.length > 0;

        const fcstStr = tafHasWx ? tafWx.join(", ") : "NSW";
        const obsStr = metarHasWx ? metarWx.join(", ") : "NSW";
        const diffHtml = `<span class="diff-highlight">Fcst: ${fcstStr}<br>Obs: ${obsStr}</span>`;

        if (!tafHasWx && !metarHasWx) return { verified: true };
        if (tafHasWx && metarHasWx)
          return { verified: true, note: "Both have weather" };
        return {
          verified: false,
          reason:
            (tafHasWx
              ? "Weather forecast but not observed"
              : "Weather observed but not forecast") + diffHtml,
        };
      }

      function verifyCloud(tafClouds, metarClouds) {
        if (!tafClouds || !metarClouds)
          return { verified: null, reason: "Missing data" };

        const getLowestCloud = (clouds) => {
          let lowest = null;
          clouds.forEach((c) => {
            if (c.height && c.height !== "///" && !isNaN(parseInt(c.height))) {
              const h = parseInt(c.height);
              if (!lowest || h < lowest) lowest = h;
            }
          });
          return lowest;
        };

        const tafLowest = getLowestCloud(tafClouds);
        const metarLowest = getLowestCloud(metarClouds);

        const formatCloud = (h) => (h ? `${h * 100}ft` : "None/NSC");
        const diffHtml = `<span class="diff-highlight">Fcst Lowest: ${formatCloud(tafLowest)}<br>Obs Lowest: ${formatCloud(metarLowest)}</span>`;

        if (!tafLowest && !metarLowest) return { verified: true };
        if (!tafLowest || !metarLowest)
          return {
            verified: false,
            reason: `Cloud coverage mismatch${diffHtml}`,
          };

        const heightFt = tafLowest * 100;
        let allowedDiff;

        if (heightFt <= 1000) {
          allowedDiff = 1; // 1 category
        } else {
          allowedDiff = heightFt * 0.3;
        }

        const actualDiff = Math.abs(tafLowest - metarLowest) * 100;

        return {
          verified: actualDiff <= allowedDiff,
          deviation: actualDiff,
          reason:
            actualDiff > allowedDiff
              ? `Height diff: ${actualDiff}ft (allowed: ${Math.round(allowedDiff)}ft)${diffHtml}`
              : null,
        };
      }

      function getForecastForTime(taf, metarTime) {
        if (!taf || !metarTime) return taf ? taf.baseForecast : null;

        const metarHour = parseInt(metarTime.hour);
        const metarDay = parseInt(metarTime.day);
        const metarTimeVal = metarDay * 24 + metarHour;

        // Check change groups in reverse order
        for (let i = taf.changes.length - 1; i >= 0; i--) {
          const change = taf.changes[i];

          if (change.type === "FM") {
            const changeHour = parseInt(change.time.hour);
            const changeDay = parseInt(change.time.day);
            const changeTimeVal = changeDay * 24 + changeHour;
            if (metarTimeVal >= changeTimeVal) {
              return { ...change, isChange: true };
            }
          } else if (change.type === "BECMG" || change.type === "TEMPO") {
            const fromHour = parseInt(change.from.hour);
            const fromDay = parseInt(change.from.day);
            const toHour = parseInt(change.to.hour);
            const toDay = parseInt(change.to.day);

            const fromTimeVal = fromDay * 24 + fromHour;
            const toTimeVal = toDay * 24 + toHour;

            if (metarTimeVal >= fromTimeVal && metarTimeVal <= toTimeVal) {
              return { ...change, isChange: true };
            }
          }
        }

        return taf.baseForecast;
      }

      function verifyForecast() {
        const alertDiv = document.getElementById("verifyAlert");
        const outputDiv = document.getElementById("verificationOutput");
        const cardsDiv = document.getElementById("verificationCards");
        const overallDiv = document.getElementById("overallStatus");

        if (decodedTAFs.length === 0) {
          showAlert(
            alertDiv,
            "Please decode a TAF first (click 'Decode TAF' button)",
            "warning",
          );
          return;
        }

        if (decodedMETARs.length === 0) {
          showAlert(
            alertDiv,
            "Please decode at least one METAR first (click 'Decode METAR' button)",
            "warning",
          );
          return;
        }

        alertDiv.className = "alert";
        outputDiv.classList.add("active");

        // Verify each METAR against TAF
        let allResults = {
          wind: [],
          visibility: [],
          weather: [],
          cloud: [],
        };

        decodedMETARs.forEach((metar) => {
          // Find matching TAF for this METAR
          const matchingTAF = decodedTAFs.find(
            (t) => t.station === metar.station,
          );

          // If no matching TAF found, skip this METAR
          if (!matchingTAF) return;

          const forecast = getForecastForTime(matchingTAF, metar.time);

          allResults.wind.push(verifyWind(forecast.wind, metar.wind));
          allResults.visibility.push(
            verifyVisibility(forecast.visibility, metar.visibility),
          );
          allResults.weather.push(
            verifyWeather(forecast.weather, metar.weather),
          );
          allResults.cloud.push(verifyCloud(forecast.clouds, metar.clouds));
        });

        // Aggregate results
        const aggregateResults = {
          wind: aggregateVerification(allResults.wind),
          visibility: aggregateVerification(allResults.visibility),
          weather: aggregateVerification(allResults.weather),
          cloud: aggregateVerification(allResults.cloud),
        };

        // Build verification cards
        let cardsHtml = "";

        const createCard = (title, result) => {
          let statusClass =
            result.verified === true
              ? "correct"
              : result.verified === false
                ? "incorrect"
                : "partial";
          let statusText =
            result.verified === true
              ? "‚úì CORRECT"
              : result.verified === false
                ? "‚úó INCORRECT"
                : "N/A";

          return `
                    <div class="verify-card ${statusClass}">
                        <h4>${title}</h4>
                        <div class="status">${statusText}</div>
                        ${result.reason ? `<p style="font-size: 0.85rem; margin-top: 10px; color: #a0a0a0;">${result.reason}</p>` : ""}
                    </div>
                `;
        };

        cardsHtml += createCard("Wind", aggregateResults.wind);
        cardsHtml += createCard("Visibility", aggregateResults.visibility);
        cardsHtml += createCard("Weather", aggregateResults.weather);
        cardsHtml += createCard("Cloud", aggregateResults.cloud);

        cardsDiv.innerHTML = cardsHtml;

        // Overall status
        const verified = Object.values(aggregateResults).filter(
          (r) => r.verified === true,
        ).length;
        const total = Object.values(aggregateResults).filter(
          (r) => r.verified !== null,
        ).length;

        let overallClass, overallText;
        if (verified === total && total > 0) {
          overallClass = "verified";
          overallText = "‚úì FULLY VERIFIED";
        } else if (verified >= total / 2) {
          overallClass = "partial";
          overallText = "‚óê PARTIALLY VERIFIED";
        } else {
          overallClass = "not-verified";
          overallText = "‚úó NOT VERIFIED";
        }

        // Add TAF Type to summary
        let tafTypeSummary = "";
        const duration = getValidityDuration(
          decodedTAFs[0].validFrom,
          decodedTAFs[0].validTo,
        );
        if (duration === 9)
          tafTypeSummary =
            '<div style="margin-bottom:10px;"><span class="badge-validity badge-short">üü¢ SHORT TAF (9 HR)</span></div>';
        else if (duration === 30)
          tafTypeSummary =
            '<div style="margin-bottom:10px;"><span class="badge-validity badge-long">üîµ LONG TAF (30 HR)</span></div>';

        overallDiv.innerHTML = `
          ${tafTypeSummary}
          <div class="overall-status ${overallClass}">${overallText}<br>
          <span style="font-size: 1rem; font-weight: normal;">${verified}/${total} parameters verified</span>
          </div>`;

        // Update charts
        updateCharts(allResults);

        showAlert(
          alertDiv,
          "Verification complete! Check results below.",
          "success",
        );
      }

      function aggregateVerification(results) {
        const validResults = results.filter((r) => r.verified !== null);
        if (validResults.length === 0)
          return { verified: null, reason: "No data available" };

        const correctCount = validResults.filter(
          (r) => r.verified === true,
        ).length;
        const incorrect = validResults.find((r) => r.verified === false);

        if (correctCount === validResults.length) {
          return { verified: true };
        } else {
          return {
            verified: false,
            reason: incorrect
              ? incorrect.reason
              : "Some parameters out of range",
          };
        }
      }

      // ========== CSV EXPORT UTILITIES ==========
      function formatDateTimeCSV(timeObj) {
        if (!timeObj) return "";
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, "0");
        return `${timeObj.day}-${month}-${year} ${timeObj.hour}:${timeObj.minute}`;
      }

      function parseWeatherParts(wxString) {
        // Parses "+TSRA" into { int: "+", desc: "TS", phen: "RA" }
        // This is a simplified parser for the CSV structure
        if (!wxString || wxString === "NSW")
          return { int: "", desc: "", phen: wxString || "" };

        let int = "";
        let desc = "";
        let phen = "";

        if (wxString.startsWith("+")) {
          int = "+";
          wxString = wxString.substring(1);
        } else if (wxString.startsWith("-")) {
          int = "-";
          wxString = wxString.substring(1);
        }

        // Check for descriptors (2 chars)
        const descriptors = [
          "MI",
          "BC",
          "PR",
          "DR",
          "BL",
          "SH",
          "TS",
          "FZ",
          "VC",
        ];
        for (let d of descriptors) {
          if (wxString.startsWith(d)) {
            desc = d;
            wxString = wxString.substring(2);
            break;
          }
        }
        phen = wxString; // Remainder is phenomenon
        return { int, desc, phen };
      }

      function downloadCSV(type = "ALL") {
        const dataToExport = [];

        // Filter data based on type
        if (type === "ALL" || type === "TAF") {
          decodedTAFs.forEach((taf) =>
            dataToExport.push({ ...taf, reportType: "TAF" }),
          );
        }
        if (type === "ALL" || type === "METAR") {
          decodedMETARs.forEach((metar) =>
            dataToExport.push({ ...metar, reportType: "METAR" }),
          );
        }

        if (dataToExport.length === 0) {
          showAlert(
            document.getElementById(
              type === "TAF"
                ? "tafAlert"
                : type === "METAR"
                  ? "metarAlert"
                  : "verifyAlert",
            ),
            "No data to export!",
            "warning",
          );
          return;
        }

        // Master Schema Headers (Matching METAR.csv + TAF/Verification extensions)
        const headers = [
          "RAW_DATA",
          "STATION",
          "DATETIME",
          "WIND_DIR",
          "WIND_SPEED",
          "WIND_GUST",
          "VISIBILITY",
          "CLOUDS",
          "TEMPERATURE",
          "DEWPOINT",
          "PRESSURE_QNH",
          "WX1_INT",
          "WX1_DESC",
          "WX1_PHEN",
          "WX2_INT",
          "WX2_DESC",
          "WX2_PHEN",
          "WX3_INT",
          "WX3_DESC",
          "WX3_PHEN",
          "REPORT_TYPE",
          "VALIDITY",
          "VERIFICATION",
          "REMARKS",
        ];

        const csvRows = [headers.join(",")];

        dataToExport.forEach((item) => {
          // Common Fields
          const raw = `"${(item.raw || "").replace(/"/g, '""')}"`;
          const station = item.station || "";

          // DateTime
          let dateTime = "";
          if (item.reportType === "METAR" && item.time)
            dateTime = formatDateTimeCSV(item.time);
          else if (item.reportType === "TAF" && item.issueTime)
            dateTime = formatDateTimeCSV(item.issueTime);

          // Wind
          let windDir = "",
            windSpd = "",
            windGust = "";
          const windObj =
            item.reportType === "TAF" ? item.baseForecast?.wind : item.wind;
          if (windObj) {
            windDir =
              windObj.direction === "Calm"
                ? "000"
                : windObj.direction === "Variable"
                  ? "VRB"
                  : String(windObj.direction).padStart(3, "0");
            windSpd = String(windObj.speed).padStart(2, "0");
            windGust = windObj.gust ? String(windObj.gust) : "";
          }

          // Visibility
          let visibility = "";
          const visObj =
            item.reportType === "TAF"
              ? item.baseForecast?.visibility
              : item.visibility;
          if (visObj) visibility = `${visObj.value} m`;

          // Clouds
          let clouds = "";
          const cloudArr =
            item.reportType === "TAF" ? item.baseForecast?.clouds : item.clouds;
          if (cloudArr && cloudArr.length > 0) {
            clouds = `"${cloudArr
              .map((c) => {
                if (c.type === "CAVOK") return "CAVOK";
                if (c.type === "NSC") return "NSC";
                let s = c.type;
                if (c.height) s += String(c.height).padStart(3, "0");
                if (c.cloudType) s += c.cloudType;
                return s;
              })
              .join(", ")}"`;
          }

          // Temp/Dew/Pressure (METAR only)
          const temp =
            item.temperature !== null && item.temperature !== undefined
              ? item.temperature
              : "";
          const dew =
            item.dewpoint !== null && item.dewpoint !== undefined
              ? item.dewpoint
              : "";
          const qnh = item.qnh || "";

          // Weather (Split into 3 groups)
          const wxArr =
            item.reportType === "TAF"
              ? item.baseForecast?.weather
              : item.weather;
          let wx1 = { int: "", desc: "", phen: "" },
            wx2 = { int: "", desc: "", phen: "" },
            wx3 = { int: "", desc: "", phen: "" };

          if (wxArr && wxArr.length > 0) {
            if (wxArr[0]) wx1 = parseWeatherParts(wxArr[0]);
            if (wxArr[1]) wx2 = parseWeatherParts(wxArr[1]);
            if (wxArr[2]) wx3 = parseWeatherParts(wxArr[2]);
          }

          // TAF Specifics
          let validity = "";
          let reportType = item.reportType;
          if (item.reportType === "TAF") {
            if (item.validFrom && item.validTo) {
              validity = `${item.validFrom.day}${item.validFrom.hour}/${item.validTo.day}${item.validTo.hour}`;
              const duration = getValidityDuration(
                item.validFrom,
                item.validTo,
              );
              if (duration === 9) reportType = "SHORT TAF";
              else if (duration === 30) reportType = "LONG TAF";
            }
          }

          // Verification Logic (Simple check if verified against any)
          let verification = "";
          let remarks = "";

          if (item.reportType === "METAR") {
            // Check verification status if TAF exists
            const taf = decodedTAFs.find((t) => t.station === item.station);
            if (taf) {
              const forecast = getForecastForTime(taf, item.time);
              const vWind = verifyWind(forecast.wind, item.wind);
              const vVis = verifyVisibility(
                forecast.visibility,
                item.visibility,
              );
              const vWx = verifyWeather(forecast.weather, item.weather);
              const vCld = verifyCloud(forecast.clouds, item.clouds);

              if (
                vWind.verified &&
                vVis.verified &&
                vWx.verified &&
                vCld.verified
              ) {
                verification = "MATCH";
              } else {
                verification = "MISMATCH";
                let reasons = [];
                if (!vWind.verified) reasons.push("Wind");
                if (!vVis.verified) reasons.push("Vis");
                if (!vWx.verified) reasons.push("Wx");
                if (!vCld.verified) reasons.push("Cloud");
                remarks = reasons.join(", ");
              }
            }
          }

          // Construct Row
          const row = [
            raw,
            station,
            dateTime,
            windDir,
            windSpd,
            windGust,
            visibility,
            clouds,
            temp,
            dew,
            qnh,
            wx1.int,
            wx1.desc,
            wx1.phen,
            wx2.int,
            wx2.desc,
            wx2.phen,
            wx3.int,
            wx3.desc,
            wx3.phen,
            reportType,
            validity,
            verification,
            `"${remarks}"`,
          ];

          csvRows.push(row.join(","));
        });

        const csvContent = csvRows.join("\n");

        // Download
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const date = new Date();
        const timestamp =
          date.toISOString().slice(0, 10).replace(/-/g, "") +
          "_" +
          date.toTimeString().slice(0, 5).replace(/:/g, "");

        link.setAttribute("href", url);
        link.setAttribute("download", `Aviation_Data_${type}_${timestamp}.csv`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // ========== CHART FUNCTIONS ==========
      function updateCharts(results) {
        // Destroy existing charts
        Object.values(charts).forEach((chart) => {
          if (chart) chart.destroy();
        });
        charts = {};

        const labels = decodedMETARs.map(
          (m, i) => `${m.time.day}${m.time.hour}${m.time.minute}Z`,
        );

        const createChart = (canvasId, label, data) => {
          const ctx = document.getElementById(canvasId).getContext("2d");

          const chartData = data.map((r) =>
            r.verified === true ? 1 : r.verified === false ? 0 : 0.5,
          );
          const colors = chartData.map((v) =>
            v === 1 ? "#4ade80" : "#f87171",
          );

          return new Chart(ctx, {
            type: "line",
            data: {
              labels: labels,
              datasets: [
                {
                  label: label,
                  data: chartData,
                  borderColor: colors,
                  backgroundColor: colors.map((c) =>
                    c === "#4ade80"
                      ? "rgba(74, 222, 128, 0.3)"
                      : "rgba(248, 113, 113, 0.3)",
                  ),
                  borderWidth: 2,
                  fill: true,
                  stepped: true,
                  pointRadius: 6,
                  pointBackgroundColor: colors,
                  pointBorderColor: "#fff",
                  pointBorderWidth: 2,
                  segment: {
                    borderColor: (ctx) => {
                      const val = ctx.p0.parsed.y;
                      return val === 1 ? "#4ade80" : "#f87171";
                    },
                    backgroundColor: (ctx) => {
                      const val = ctx.p0.parsed.y;
                      return val === 1
                        ? "rgba(74, 222, 128, 0.3)"
                        : "rgba(248, 113, 113, 0.3)";
                    },
                  },
                },
              ],
            },
            options: {
              plugins: {
                zoom: {
                  pan: {
                    enabled: true,
                    mode: "x",
                    modifierKey: null,
                  },
                  zoom: {
                    wheel: {
                      enabled: true,
                    },
                    pinch: {
                      enabled: true,
                    },
                    mode: "x",
                  },
                },
                legend: {
                  display: false,
                },
                tooltip: {
                  callbacks: {
                    label: function (context) {
                      const result = data[context.dataIndex];
                      if (result.verified === true) return "Verified ‚úì";
                      if (result.reason) return result.reason;
                      return "Not verified";
                    },
                  },
                },
              },
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  min: -0.2,
                  max: 1.2,
                  ticks: {
                    callback: function (value) {
                      if (value === 1) return "Match";
                      if (value === 0) return "Mismatch";
                      return "";
                    },
                    color: "#a0a0a0",
                  },
                  grid: {
                    color: "rgba(255,255,255,0.1)",
                  },
                },
                x: {
                  ticks: {
                    color: "#a0a0a0",
                  },
                  grid: {
                    color: "rgba(255,255,255,0.1)",
                  },
                },
              },
            },
          });
        };

        charts.wind = createChart("windChart", "Wind", results.wind);
        charts.visibility = createChart(
          "visibilityChart",
          "Visibility",
          results.visibility,
        );
        charts.weather = createChart(
          "weatherChart",
          "Weather",
          results.weather,
        );
        charts.cloud = createChart("cloudChart", "Cloud", results.cloud);
      }

      function toggleCharts() {
        const grid = document.querySelector(".chart-grid");
        const btn = document.getElementById("chartToggleBtn");
        grid.classList.toggle("expanded");

        if (grid.classList.contains("expanded")) {
          btn.innerHTML = '<i class="fas fa-compress"></i> Compact View';
        } else {
          btn.innerHTML = '<i class="fas fa-expand"></i> Expand View';
        }
      }

      function zoomCharts(amount) {
        Object.values(charts).forEach((chart) => {
          if (chart) chart.zoom(amount);
        });
      }

      function resetCharts() {
        Object.values(charts).forEach((chart) => {
          if (chart) chart.resetZoom();
        });
      }

      // ========== THEME & UTILS ==========
      function toggleTheme() {
        document.body.classList.toggle("light-mode");
        const isLight = document.body.classList.contains("light-mode");
        localStorage.setItem("theme", isLight ? "light" : "dark");
        updateThemeIcon(isLight);
      }

      function updateThemeIcon(isLight) {
        const btn = document.getElementById("themeToggle");
        btn.innerHTML = isLight
          ? '<i class="fas fa-moon"></i>'
          : '<i class="fas fa-sun"></i>';
      }

      // Initialize
      document.addEventListener("DOMContentLoaded", () => {
        const savedTheme = localStorage.getItem("theme");
        if (savedTheme === "light") {
          document.body.classList.add("light-mode");
          updateThemeIcon(true);
        }

        // Visitor Count
        let count = parseInt(localStorage.getItem("page_views") || "1116");
        count++; // Increment count on each visit
        localStorage.setItem("page_views", count.toString());
        const el = document.getElementById("visitorCount");
        if (el) el.innerText = count;

        // Close dropdown when clicking outside
        document.addEventListener("click", function (event) {
          const dropdown = document.getElementById("navDropdown");
          const logo = document.querySelector(".logo-img");
          if (
            !logo.contains(event.target) &&
            !dropdown.contains(event.target)
          ) {
            dropdown.classList.remove("show");
          }
        });
      });

      // ========== UI FUNCTIONS ==========
      function toggleDropdown(event) {
        if (event) event.stopPropagation();
        document.getElementById("navDropdown").classList.toggle("show");
      }

      function openModal(modalId) {
        document.getElementById(modalId).classList.add("active");
        document.getElementById("navDropdown").classList.remove("show");
      }

      function closeModal(modalId) {
        document.getElementById(modalId).classList.remove("active");
      }

      function toggleInfoSection() {
        const grid = document.getElementById("infoGrid");
        const icon = document.getElementById("infoToggleIcon");
        grid.classList.toggle("show");
        if (grid.classList.contains("show")) {
          icon.style.transform = "rotate(180deg)";
        } else {
          icon.style.transform = "rotate(0deg)";
        }
      }
    </script>
  </body>
</html>
